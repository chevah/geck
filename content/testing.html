---
page_title: Testing
---

.. contents::

Writing tests is an important part of development job.

Tests serve as examples of how to use a class, method, a module or the whole
product.

Once used to having tests that show how things work (and that they do work), you
will start using the key phrase: **Do you have a test for that?**.


Types of tests
==============

Tests can be placed in many categories according to various criteria.

Below is an attempt to identify various types of tests based on their interaction
with other code / systems.


Unit testing
------------

This is the least controversial type of tests, and people usually know what
unit tests are.

Test for single method or functions. As the number of unit tests significantly grows
throughout the lifecycle of te project one key requirement is that they run as
fast as possible. Therefore the tests should use only data from memory for both input 
and output.


Integration testing
-------------------

These are the tests which take what was tested using unit tests (functions,
methods) and combine / integrate them in bigger tests for the whole module or even
module interactions.

The time / speed restrictions still apply. They should also use only data from memory.

Try to test all corner cases regarding the component's integration.

Don't write corner cases for a specific component since they *should* be handled at
unit testing level. If that is not the case please revise the unit tests accordingly.

The purpose of integration testing is to detect any inconsistencies between
the software units / modules that are integrated together or between any
modules and the hardware.

Since they should be fast, you can put them together with unit tests.


System testing
--------------

In contrast with unit or functional tests, these test have no restriction for
interacting with external systems.

A test is a system test if:

* It touches the file system.
* It talks to the database.
* It communicates across the network.
* It uses some type of shared resource and can't run at the same time as
  any other unit tests.
* You have to do special things to prepare your environment.
* Requires a special OS account / OS credentials to exists.

They interact with local filesystem, network and other services provided by
the operating system.

While interacting with external system, system tests require additional
steps in configuration and preparing the external system for running the
tests, so their execution depend on these external systems.
Example: configure an OS account, do special network configuration,
configure a printer, create certain files or folder structures on the
filesystem.

The external services are "black boxes", as we don't have access to their
internal structure.

They test the integration with external services, and at some
extend they are integration tests.

Due to interaction with external system, system tests are slower than unit or
integration tests.

While configuring external systems, take special care to avoid side effects or
leaving the system in an inconsistent tests that will not allow other tests
to execute. At the end of the test, leave the system in the same state as the
one from the start.

We put them in separate test suites due to speed and dependency on
external systems.


Functional testing
------------------

These are the tests for the final product. All modules are put together just
like in the production (real) system.

You can consider them black box testing as their role is to check that the
system, as a whole, works.

While for functional tests only external systems are handled as black boxes,
for functional testing the system under test is also handled as a black box.

They will read actual input just like the real life application and will
produce actual, real life, results.

Don't do too much work here and don't bother with corner cases.
A simple success scenario and a failure scenario should be enough.

Sometimes reading and writing actual input can slow tests, so for performance
reasons, some system tests also read and write data in memory, but the format
used closely resembles the one used in real life, production environments.


Developing using tests
======================

As there is no guarantee for the order in which the tests will execute there is
one major requirement, regardless of the test type. The *test should not have any
side effect* as the order of execution is random.

When writing application code, only write enough code to make a test work.
If you know there should be more code to handle other cases, you should write the tests 
for those particular cases. This technique prevents writing code that is never executed 
and ensures that you always have a test for the code you write.


Group multiple / related calls into dedicated, helper methods. Give the method
an easy to read name. Try to create a Domain Specific Language for your tests.


.. sourcecode:: python

    class TestSuperUser(TestCase):
        """
        Tests for super user.
        """

        def test_rename_ulgy(self):
            """
            Users can be renamed just by calling rename() on the user object.

            Ugly initialization code.
            """
            username = factory.makeUsername()
            new_username = factory.makeUsername()
            configuration = factory.makeSuperConfiguration()
            configuration.addUser(username)
            user = configuration.getUser(username)
            user.enabled = True

            user.rename(new_username)

            self.assertTrue(configuration.userExists(new_username))
            self.assertFalse(configuration.userExists(username))

        def makeUser(self, username, configuration=None):
            """
            Return a new username created for `configuration`.

            If `configuration` is `None` it will use a new configuration.
            """
            if configuration is None:
                configuration = factory.makeSuperConfiguration()
            configuration.addUser(username)
            user = configuration.getUser(username)
            user.enabled = True
            return user

        def test_rename_clean(self):
            """
            Users can be renamed just by calling rename() on the user object.

            Clean version.
            """
            username = factory.makeUsername()
            new_username = factory.makeUsername()
            user = self.makeUser(username)

            user.rename(new_username)

            self.assertTrue(configuration.userExists(new_username))
            self.assertFalse(configuration.userExists(username))


Structure of a test
-------------------

Use the **Assert, Act, Arrange,** pattern: each part must have it's own paragraph.

 * **Arrange** is variable declaration and initialization code.
   Set up all conditions and environment for testing.
 * **Act** is invoking the code being tested.
   Call the method or trigger the necessary state.
 * **Assert** is using the assert methods or any other code to verify that
   expectations were met.

For integration tests, this can also be called **Assemble, Activate, Assert**.

The tests needs to be short and easy to read.

Some test might not require the *arrange* part.

Make sure to test only a single thing at once.

When *asserting* that *acting* on a code raised an exception, these two steps
might get intertwined and look like the following code. This is OK.

.. sourcecode:: python

    def test_getAllProperties_no_accounts(self):
        """
        An error is raised if no accounts are defined.
        """

        with self.assertRaises(ConfigurationError):
            some.getAllProperties()

The *arrange* part can get very long. Try to move as much code in setUp()
method, or move related initialization code in a helper method.

When the code is used only in a few tests, put it in a dedicated, reusable, method.

.. sourcecode:: python

    def test_section_navigation_long_arrange(self):
        """
        This does not uses setUp or other
        """
        account = factory.makeTestAccount()
        browser = factory.makeTestBrowser()
        browser.open(self.BASE_URL + '/login')
        browser.setField('username', account.name)
        browser.setField('password', account.password)
        browser.clickButton('Submit')

        browser.open(self.BASE_URL + '/some_section')

        self.assertEqual('section_title', browser.title)

    def setUp(self):
        """
        Object used by almost all tests.
        """
        super(X, self).setUp()
        self.account = factory.makeTestAccount()
        self.browser = factory.makeTestBrowser()

    def login(self):
        """
        Go to login page and submit username and password.
        """
        self.browser.open(self.BASE_URL + '/login')
        self.browser.setField('username', self.account.name)
        self.browser.setField('password', self.account.password)
        self.browser.clickButton('Submit')

    def test_section_navigation(self):
        """
        After login, users can navigate to specific sections.
        """
        self.login()

        self.browser.open(self.BASE_URL + '/some_section')

        self.assertEqual('section_title', self.browser.title)


Especially on some integration test or system tests, you also have one last part
for a test: the cleanup. It is recommended to do it in tearDown() but when not
practical, do it as a new paragraph, at the end of the test.


Naming conventions
------------------

* All test cases should have names prefixed with `Test`.
* Include the tested class name in the name of the test case.
* When multiple test cases exist for the same class, suffix the test case with
  some hints about the special cases in each test case.

.. sourcecode:: python

    class TestSuperButtonInSpace(TestCase):
        """
        Test for super button behavior in space.
        """

        def setUp():
            super(TestSuperButtonInSpace, self).setUp()
            DO YOUR SPACE INITIALIZATION HERE.

    class TestSuperButtonOnEarth(TestCase):
        """
        Test for super button behavior on earth.
        """

        def setUp():
            super(TestSuperButtonOnEarth, self).setUp()
            DO YOUR EARTH INITIALIZATION HERE.

* All methods that perform tests should be prefixed with `test_`.
* If testing a specific method, include the exact name of the method, in the
  test name, at the beginning, just after the `test_` marker.
* When there are multiple tests for the same method, suffix the test with
  a short underline ("_") delimited summary. No need to add all details in the name.
  Just make sure it is unique in the test case. Avoid long descriptions, you
  can add everything in the docstring.

.. sourcecode:: python

    def test_getAllProperties_no_accounts(self):
        """
        An empty dictionary is returned if no accounts are defined.
        """


Tests description - docstrings
------------------------------

Each test should have a description (docstring) with information about the
purpose of the test or any other additional info that could help another
person to understand the test.

Writing docstring for tests is not easy, but doing so will reduce the
WTF/minute.

* Describe in simple plain English what you are testing and what is the
  expected behaviour.

* Think of the test's docstring as an extension of documentation for the
  method under tests.

* For integration tests add notes about pre-conditions or other requirements.

* Add a brief description and don't describe how the test is done.
  Detailed information about the test should be available by reading
  the code implementing the tests.
  When code fails to speak for itself use inline comments.

* Avoid including the name of the method under tests. The test method name
  should already include it.

* When testing for raised exceptions avoid adding the exception name in
  the test description. Just inform that an exception is raised. By
  reading the test code, it should be easy to get more details about the
  exception.


Here are some tips from Jonathan Lange as a handy five-step guide:

1. Write the first docstring that comes to mind. It will almost certainly be::

    """Test that input is parsed correctly."""

2. Get rid of "Test that" or "Check that". We know it's a test.::

    """Input should be parsed correctly."""

3. Seriously?! Why'd you have to go and add "should"? It's a test,
   it's all about "should". ::

    """Input is parsed correctly."""

4. "Correctly", "properly", and "as we expect" are all redundant.
   Axe them too. ::

    """Input is parsed."""

5. Look at what's left. Is it saying anything at all?
   If so, great. If not, consider adding something specific about the test
   behaviour and perhaps even why it's desirable behaviour to have. ::

    """
    Input is parsed into an immutable dict according to the config
    schema, so we get config info without worrying about input
    validation all the time.
    """

6. Happy hacking!

Rerefences:

 * http://integralpath.blogs.com/thinkingoutloud/2005/09/principles_of_t.html
 * https://plus.google.com/115348217455779620753/posts/YA3ThKWhSAj
 * http://c2.com/cgi/wiki?ArrangeActAssert
